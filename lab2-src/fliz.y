/*
 * CS-252 Spring 2017
 * fiz.y: parser for the FIZ interpreter
 */


/********************************************************************************
 * Beginning of Section 1: Definition of tokens and non-terminal in the grammar *
 ********************************************************************************/ 

// tokens are generated by the lexical analyzer specified in fiz.l
// The ID token is used for function name, formal argument name, and usage of argument in function body
// its value is a string.  The token ID has a string value associated with it, here <string_val> refers
// to the "char *string_val" member in %union below
%token <string_val> ID			

// The token NUMBER has a integer value associated with it, here <number_val> refers to the 
// int number_val member in %union below
%token <number_val> NUMBER 
// These tokens do not have associated values
////////////////////////////////////////////////////////Change HERERERERE!!!//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
%token DEFINE HALT OPENPAR CLOSEPAR OPENBRAC CLOSEBRAC

// This declares that in the grammar, the non terminals expr, expr_list, and arg_list have 
// a value "struct TREE_NODE *node_val" associated with it
%type <node_val> expr expr_list arg_list const_expr 

%union    {
	char   *string_val;
	int    number_val;
	struct TREE_NODE *node_val;
}

%{
	/********************************************************************************
	 * Beginning of Section 2: C data type and global variable definitions to be    *
	 *  included in the generated y.tab.c file                                      *
	 ********************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

	void yyerror(const char * s);
	void prompt();
	int yylex();

#define MAX_FUNCTIONS 1000
#define MAX_ARGUMENTS 10
#define NUM_BUILTIN   5

	// The types of nodes that may occur in a syntax tree
	enum NODE_TYPE
	{
		HALT_NODE,      // corresponds to (halt)
		BUILTIN_FUNC,   // corresponds to built-in functions such as (inc ...) (dec ...) (ifz ... ... ...)
		FUNC_CALL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS 
		// before the function is resolved, i.e., fname are still stored as strings
		FUNC_EVAL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS
		// after the function has been resolved, that is, matching function has been found
		NUMBER_NODE,    // 
		ARG_NAME,       // corresponds to the usage of an ID in the body of the definition of a function,
		// it indicates the usage of an argument, we are keeping it as a string
		ARG_INDEX,      // corresponds to the usage of an ID in the body of the definition of a function,
		// it has been resolved to indicate the index of the argument 
		ARG_LIST,        // corresponds to a list of formal arguments constructed during parsing in a function definition
		//////////////////////////
		CONSTANT
	};

	// Below is the data type for a node in the syntax tree
	struct TREE_NODE
	{
		enum NODE_TYPE type;
		union {
			struct {
				struct BUILTIN_DECL *decl;
				int    numArgs;
				struct TREE_NODE *args[MAX_ARGUMENTS];
			} builtin_func;                      // For BUILTIN_FUNC
			struct {
				char *name;
				int    numArgs;
				struct TREE_NODE *args[MAX_ARGUMENTS];
			} func_call;                        // For FUNC_CALL
			struct {
				struct FUNC_DECL *func;
				int    numArgs;
				struct TREE_NODE *args[MAX_ARGUMENTS];
			} func_eval;                        // For FUNC_EVAL
			struct {
				int    numArgs;
				char * argNames[MAX_ARGUMENTS];
			} arg_list;                         // For ARG_LIST
			struct {
				struct TREE_NODE*  next;
				struct TREE_NODE*  prev;
				struct TREE_NODE*  inception;
				int type; /* type of node 1 for number 0 for list */
				int * value; /* will be null if sentinel */
			} constE;    	

			int    intValue;                    // For NUMBER_NODE and ARG_INDEX
			char   *strValue;                   // For ARG_NAME
		};
	};

	// Information we maintain for each built-in function
	struct BUILTIN_DECL {
		char *name;
		int numArgs;
		struct TREE_NODE * (* body)(struct TREE_NODE* node, struct TREE_NODE ** env);		// Body of the function
		// support printing that occurs when tracing is on
	};

	// Information we maintain for each defined function
	struct FUNC_DECL {
		char *name;              // Function name
		int  numArgs;            // Number of arguments
		char *argNames[MAX_ARGUMENTS];         // Names of formal arguments
		int  resolved;           // Whether the body expression has been resolved.
		struct TREE_NODE * body; // Point to the expression representing the body of a function
	};

	// Stores the definitions of functions defined using (define ...)
	struct FUNC_DECL functions[MAX_FUNCTIONS];
	int numFuncs = 0;
	/*****************************************************************************************************/
	int top;
	struct TREE_NODE * gcStack;
	struct TREE_NODE * start;
	void free_tree(struct TREE_NODE * node);
	/*****************************************************************************************************/
	// Global variables
	int err_value = 0;
	int loading = 0;
	int tracing = 0;
	int depth = 0;

	// Find a builtin function by name
	struct BUILTIN_DECL * find_builtin(char *name);

	// Find a function by name
	struct FUNC_DECL * find_function(char *name);

	// Resolve the body of a function to prepare it for evaluation
	void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf);

	// Evaluate a function
	struct TREE_NODE * eval(struct TREE_NODE * node, struct TREE_NODE ** env);
	struct TREE_NODE * listDup(struct TREE_NODE * node);
	void freeStack();
	void freeList(struct TREE_NODE * node);
	void print(struct TREE_NODE * node);
	int contains(struct TREE_NODE * node);
	void freeStack() {
	/*	//printf("Entered free %d %ld\n",top,sizeof(struct TREE_NODE*));
		while(top > 0){
			free_tree(gcStack[--top]);
			gcStack[top] = NULL;
		}
*/	}

	void freeList(struct TREE_NODE * node) {
		if(node == NULL) return;
		if(node->constE.value != NULL)
		free(node->constE.value);
		node->constE.value = NULL;
		freeList(node->constE.next);
		node->constE.next = NULL;
		freeList(node->constE.inception);
		node->constE.inception = NULL;
	}

	int contains(struct TREE_NODE * node) {
/*		int i = 0;
		while(i < top) if(gcStack[i++] == node) return 1;
*/		return 0;
	}

	struct TREE_NODE * listDup(struct TREE_NODE * node) {
		if(node == NULL) return node;
		struct TREE_NODE * newNode = (struct TREE_NODE *)(malloc(sizeof(struct TREE_NODE)));
		newNode->type = node->type;
		newNode->constE.type = node->constE.type;
		newNode->constE.next = listDup(node->constE.next);
		newNode->constE.inception = listDup(node->constE.inception);
		if(node->constE.value != NULL) {
			int x = *node->constE.value;
			newNode->constE.value = (int *)(malloc(sizeof(int)));
			*newNode->constE.value = x;
		} else {
			newNode->constE.value = NULL;
		}
		return newNode;
	}
	


	struct TREE_NODE * eval_head(struct TREE_NODE * node, struct TREE_NODE ** env);
	struct TREE_NODE * eval_tail(struct TREE_NODE * node, struct TREE_NODE ** env);
	struct TREE_NODE * eval_list(struct TREE_NODE * node,  struct TREE_NODE ** env);
	struct TREE_NODE * eval_ifn(struct TREE_NODE * node, struct TREE_NODE ** env);
	struct TREE_NODE * eval_ifa(struct TREE_NODE * node, struct TREE_NODE ** env);

	// The global variable of all builtin functions
	struct BUILTIN_DECL builtin_functions[NUM_BUILTIN] = {
		{"head", 1, &eval_head},
		{"tail", 1, &eval_tail},
		{"list", 2, &eval_list},
		{"ifn", 3, &eval_ifn},
		{"ifa", 3, &eval_ifa}
	};

	%}

	%%
	/********************************************************************************
	 * Beginning of Section 3: Grammar production rule definitions and associated   *
	 *  C code                                                                      *
	 ********************************************************************************/ 

	statements:
	statement 
	|
	statements statement
	;

statement:
OPENPAR DEFINE OPENPAR ID arg_list CLOSEPAR expr CLOSEPAR     // define a function`
{
	if (find_builtin($4) != NULL) {
		fprintf(stderr, "Cannot redefine builtin function %s.\n", $4);
	} 
	else if (find_function($4) != NULL) {
		fprintf(stderr, "Function %s already defined.\n", $4);
	} 
	else if ($5-> arg_list.numArgs > MAX_ARGUMENTS) {
		fprintf(stderr, "Sorry, we allow only %d arguments in a function.", MAX_ARGUMENTS);
	} 
	else if (numFuncs == MAX_FUNCTIONS) {
		fprintf(stderr, "Sorry, we allow only %d number of functions to be defined. \n", MAX_FUNCTIONS);
	} 
	else {   // No error, add definition for the function
		int i;
		functions[numFuncs].name = $4; 
		functions[numFuncs].numArgs = $5->arg_list.numArgs;
		for (i=0; i<$5->arg_list.numArgs; i++) {
			functions[numFuncs].argNames[i] = $5->arg_list.argNames[i];
		}
		free($5);
		$5 = NULL;
		functions[numFuncs].body = $7;
		// Do not resolve now, because the body may use function not yet defined. 
		functions[numFuncs].resolved = 0;	
		numFuncs++;
		printf("Function %s defined.\n", $4);
	}
}
| 
expr		// An expression
{
	resolve($1, NULL);
	if (err_value == 0) {

		//print($1);
		struct TREE_NODE * n = eval($1, NULL);
		print(n);
		printf("\n");
		free_tree(n); /* doesn't eliminate the leaks but reduces it! */
	}
	err_value = 0;
}
;

arg_list:
ID 
{
	struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
	node -> type = ARG_LIST;
	node -> arg_list.numArgs = 1;
	node -> arg_list.argNames[0] = $1;
	$$ = node;
}
| arg_list ID
{
	if ($1 -> arg_list.numArgs >= MAX_ARGUMENTS) {
		fprintf (stderr, "Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);		
		free($2);
		$2 = NULL;
		err_value = 1;
	} else {
		$1 -> arg_list.argNames[$1->arg_list.numArgs] = $2;
		$1 -> arg_list.numArgs++;
	}
	$$ = $1;
}

expr_list:        
expr
{
	// expr_list can be used only as actual arguments in a function invocation
	struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
	node -> type = FUNC_CALL;
	node -> func_call.numArgs = 1;
	node -> func_call.args[0] = $1;
	$$ = node;
}
| expr_list expr
{
	if ($1 -> func_call.numArgs >= MAX_ARGUMENTS) {
		printf ("Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);
 //		free_tree($2);
		err_value = 2;
	} else {
		$1 -> func_call.args[$1->func_call.numArgs] = $2;
		$1 -> func_call.numArgs++;
	}
	$$ = $1;
}
;

expr: 
OPENPAR HALT CLOSEPAR
{
	struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
	node -> type = HALT_NODE;
	$$ = node;
}
|
ID
{
	struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
	node -> type = ARG_NAME;
	node -> strValue = $1;
	$$ = node;
}
|
OPENPAR ID expr_list CLOSEPAR
{
	struct BUILTIN_DECL *builtin = find_builtin($2);
	$3 -> func_call.name = $2;
	if (builtin != NULL) {	// Usage of a built-in function
		if (builtin->numArgs != $3->func_call.numArgs) {
			fprintf (stderr, "The built-in function %s expects %d arguments; you have %d.", 
					builtin->name, builtin->numArgs, $3->func_call.numArgs);
			err_value = 3;
		} else {
			$3 -> type = BUILTIN_FUNC;
			$3 -> builtin_func.decl = builtin;
			free($2);			// Name string no longer needed
			$2 = NULL;
		}
	}
	$$ = $3;
}
|
OPENBRAC const_expr CLOSEBRAC
{
	struct TREE_NODE * sentinel = (struct TREE_NODE *) (malloc(sizeof(struct TREE_NODE)));
	sentinel->type = CONSTANT;
	struct TREE_NODE * temp = $2;

	sentinel->constE.type = 0;
	sentinel->constE.next = NULL;
	sentinel->constE.inception = temp;
	sentinel->constE.value = NULL;
	$$ = sentinel;/*make a whole list an 'expr'*/
}
|
OPENBRAC CLOSEBRAC
{
	struct TREE_NODE * temp = (struct TREE_NODE *) (malloc(sizeof(struct TREE_NODE)));
	temp->type = CONSTANT;
	temp->constE.next = NULL;
	temp->constE.inception = NULL;	
	temp->constE.value = NULL;
	temp->constE.type = 2;
	$$ = temp;
}
|
NUMBER
{
	struct TREE_NODE * temp = (struct TREE_NODE *) (malloc(sizeof(struct TREE_NODE)));
	temp->type = CONSTANT;
	temp->constE.value = (int*)(malloc(sizeof(int)));
	*(temp->constE.value) = $1;
	temp->constE.next = NULL;
	temp->constE.inception = NULL;
	temp->constE.type = 1;
	$$ = temp;
}
;

const_expr:
OPENBRAC CLOSEBRAC
{
	struct TREE_NODE * temp = (struct TREE_NODE *) (malloc(sizeof(struct TREE_NODE)));
	temp->type = CONSTANT;
	temp->constE.value = NULL;
	temp->constE.next = NULL;
	temp->constE.inception = NULL;
	temp->constE.type = 2;	


	$$ = temp;
}
|
NUMBER
{
	struct TREE_NODE * temp = (struct TREE_NODE *) (malloc(sizeof(struct TREE_NODE)));
	temp->type = CONSTANT;
	temp->constE.value = (int*)(malloc(sizeof(int)));
	*(temp->constE.value) = $1;
	temp->constE.next = NULL;
	temp->constE.inception = NULL;
	temp->constE.type = 1;
	$$ = temp;
}
|
OPENBRAC const_expr CLOSEBRAC
{
	struct TREE_NODE * sentinel = (struct TREE_NODE *) (malloc(sizeof(struct TREE_NODE)));
	sentinel->type = CONSTANT;
	struct TREE_NODE * temp = $2;

	sentinel->constE.type = 0;
	sentinel->constE.next = NULL;
	sentinel->constE.inception = temp;
	sentinel->constE.value = NULL;
	//	print(sentinel);
	$$ = sentinel;
}
|
const_expr const_expr
{
	struct TREE_NODE * temp = $1;
	struct TREE_NODE * otherTemp = $2;

	while(temp->constE.next!=NULL) temp = temp->constE.next;
	temp->constE.next = otherTemp;
	$$ = $1;
}



;

%%
/********************************************************************************
 * Beginning of Section 4: C functions to be included in the y.tab.c.           *
 ********************************************************************************/ 


void free_tree(struct TREE_NODE * node)
{
    int i;
    if(node==NULL) return;
    //printf("Entered freeTree\n");
    switch(node->type)
    {
        //case NUMBER_NODE:
        case ARG_INDEX:
        case HALT_NODE:
            break;
	case CONSTANT: {
		if(node->constE.value != NULL)
		free(node->constE.value);
		//node->constE.value = NULL;
		free_tree(node->constE.next);
		//node->constE.next = NULL;
		free_tree(node->constE.inception);
		//node->constE.inception = NULL;	
		break;
	}
        case ARG_NAME:        
            free(node->strValue);
            break;
        case BUILTIN_FUNC:
            for (i=0; i<node->builtin_func.numArgs; i++) {
                free_tree(node->builtin_func.args[i]);
            }
            break;
        case FUNC_EVAL:
            for (i=0; i<node->func_eval.numArgs; i++) {
                free_tree(node->func_eval.args[i]);
            }
            break;
        case FUNC_CALL:
            free(node->func_call.name);
            for (i=0; i<node->func_call.numArgs; i++) {
                free_tree(node->func_call.args[i]);
            }
            break;
        case ARG_LIST:
            for (i=0; i<node->arg_list.numArgs; i++) {
                free(node->arg_list.argNames[i]);
            }
            break;
        default:
            fprintf(stderr, "Unexpected node type during freeing. %d\n",node->type);
            exit(1);
    }
    //printf("Exiting freeTree\n");
    free(node);
    node = NULL;
}

void print(struct TREE_NODE * node) {
	if(node == NULL) return;
	int type = node->constE.type;
	if(type == 1) {
		printf(" %d",*node->constE.value);
	} else if(type == 0) {
		printf(" [");
		print(node->constE.inception);
		printf(" ]");
	}
	else if(type == 2) {
		printf(" [ ]");
	}
	print(node->constE.next);
}


struct BUILTIN_DECL * find_builtin(char *name)
{
	int i;
	for (i=0; i<NUM_BUILTIN; i++) {
		if (strcmp(builtin_functions[i].name, name) == 0)
			return &builtin_functions[i];
	}
	return NULL;
}


struct FUNC_DECL * find_function(char *name)
{
	int i;
	for (i=0; i<numFuncs; i++) {
		if (! strcmp(functions[i].name, name))
			return &functions[i];
	}
	return NULL;
}

/* Resolve an expression pointed to by node, possibly in the context of a function 
   body.  */
void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf)
{
	struct FUNC_DECL *f = NULL;

	int i;
	switch(node->type)
	{
		case ARG_NAME:        // Use of an argument
			if (cf != NULL) { //
				for (i=0; i<cf->numArgs; i++) {
					if (! strcmp(node->strValue, cf->argNames[i])) {
						free(node->strValue);
						node->type = ARG_INDEX;
						node->intValue = i;
						break;
					}
				}
			}
			if (node->type != ARG_INDEX) {
				fprintf(stderr, "Usage of identifier %s undefined\n", node->strValue);
				err_value = 1;
			}
			break;

		case FUNC_CALL:
			f = find_function(node->func_call.name);
			if (f == NULL) {
				fprintf(stderr, "Function %s not found\n", node->func_call.name);
				err_value = 1;
				break;
			}
			if (f->numArgs != node->func_call.numArgs) {
				fprintf(stderr, "Usage of function %s has %d arguments, definition of function %s has %d arguments.\n", 
						f->name, node->func_eval.numArgs, f->name, f->numArgs);
				err_value = 1;
				break;
			}
			free(node->func_call.name);
			for (i=0; i<f->numArgs; i++) {
				resolve(node->func_call.args[i], cf);
			}
			node->type = FUNC_EVAL;
			node->func_eval.func = f;
			break;

		case BUILTIN_FUNC:
			for (i=0; i<node->builtin_func.numArgs; i++) {
				resolve(node->builtin_func.args[i], cf);
			}
			break;
	}
}

//Evaluates an expression node
struct TREE_NODE * eval(struct TREE_NODE * node, struct TREE_NODE ** env)
{
	struct FUNC_DECL   *f;
	int i;
	struct TREE_NODE * v;
	struct TREE_NODE * e[MAX_ARGUMENTS];
	depth ++;
	switch(node->type)
	{
		case CONSTANT:
			v = node;
			break;
		case ARG_INDEX:
			v = env[node->intValue];
			break;
		case BUILTIN_FUNC:
			v= (node->builtin_func.decl->body)(node, env);
			break;

		case HALT_NODE:
			fprintf(stderr, "Halted\n");
			exit(1);

		case FUNC_EVAL:
			f = node->func_eval.func;
			if (! f->resolved) {
				resolve(f->body, f);
			}

			for (i=0; i<f->numArgs; i++) {
				e[i] = eval(node->func_eval.args[i], env);
			}

			v = eval(f->body, e);

			break;

		default:
			fprintf (stderr, "Unexpected node %d\n", node->type); 
			exit(3);
	}
	depth --;
	return v;
}

/*********************************************************
 * Begin of supporting code for the built-in functions.  *
 *********************************************************/
struct TREE_NODE * eval_head(struct TREE_NODE * node, struct TREE_NODE ** env) {
	struct TREE_NODE * temp = eval(node->builtin_func.args[0], env);	
	if(temp == NULL) return NULL;
	
	if(temp->constE.type != 0) {
		printf("Error in head\n");
		exit(1);
	}
	
	struct TREE_NODE * s = temp;


	temp = temp->constE.inception;
	struct TREE_NODE * next = temp->constE.next;
	temp->constE.next = NULL;
	struct TREE_NODE * out = listDup(temp);
	temp->constE.next = next;
	out->constE.next = NULL;
	return out;
}
struct TREE_NODE * eval_tail(struct TREE_NODE * node, struct TREE_NODE ** env) {
	struct TREE_NODE * temp = eval(node->builtin_func.args[0], env);
	if(temp == NULL) return NULL;
	
		
	if(temp->constE.type != 0) {
		printf("Error in tail\n");
		exit(1);
	}

	struct TREE_NODE * s = temp;

	temp = temp->constE.inception;
	struct TREE_NODE * prev = temp;
	temp = temp->constE.next;
	struct TREE_NODE * out = listDup(temp);

	struct TREE_NODE * sentinel = (struct TREE_NODE *) (malloc(sizeof(struct TREE_NODE)));
	sentinel->type = CONSTANT;

	sentinel->constE.type = 0;
	sentinel->constE.next = NULL;
	sentinel->constE.prev = NULL;
	sentinel->constE.inception = out;
	if (out == NULL) sentinel->constE.type = 2;
	sentinel->constE.value = NULL;
	temp = prev;
	return sentinel;
}
struct TREE_NODE * eval_list(struct TREE_NODE * node,  struct TREE_NODE ** env) {

	struct TREE_NODE * head = eval(node->builtin_func.args[0], env);
	if(head == NULL) return NULL;

	
	
	struct TREE_NODE * tail = eval(node->builtin_func.args[1],env);
	if(tail == NULL) return head;/***********************/




	struct TREE_NODE * newHead = listDup(head);
	struct TREE_NODE * newTail = listDup(tail);

	if(newTail->constE.type == 1) {
		printf("Error in list\n");
		exit(1);
	
	}
	newHead->constE.next = newTail->constE.inception;
	newTail->constE.inception = newHead;
	newTail->constE.type = 0;
	return newTail;
}
struct TREE_NODE * eval_ifn(struct TREE_NODE * node, struct TREE_NODE ** env) {
	struct TREE_NODE * temp = eval(node->builtin_func.args[0], env);
	struct TREE_NODE * out;
	if(temp->constE.type == 2) {
	 out = eval(node->builtin_func.args[1], env);
	} else {
	 out = eval(node->builtin_func.args[2], env);
	}

	out = listDup(out);
	return out;
}
struct TREE_NODE * eval_ifa(struct TREE_NODE * node, struct TREE_NODE ** env) {
	struct TREE_NODE * temp = eval(node->builtin_func.args[0], env);
	if(temp == NULL) return NULL;
	struct TREE_NODE * out;
	/*if(temp->constE.type == 0) {
		temp = temp->constE.inception;
	}*/
	if(temp->constE.type == 1) {
	 out = eval(node->builtin_func.args[1], env);
	} else {
	 out = eval(node->builtin_func.args[2], env);
	}

	out = listDup(out);



	return out;
}



/*********************************************************
 * End of supporting code for the built-in functions.  *
 *********************************************************/

void yyerror(const char * s)
{
	fprintf(stderr,"%s", s);
}

void prompt()
{
	if (! loading) {
		printf("fliz> ");
	}
}

main(int argc, char *argv[])
{
	gcStack = (struct TREE_NODE *)(malloc(sizeof(struct TREE_NODE)));
	prompt();
	yyparse();
	return 0;
}

